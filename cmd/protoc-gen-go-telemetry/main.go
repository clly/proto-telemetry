package main

import (
	"flag"

	fields "github.com/clly/proto-telemetry/cmd/pkg/generators"
	"github.com/clly/proto-telemetry/cmd/pkg/logger"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

type config struct {
	includeMap bool
	logLevel   int
}

func main() {
	var flags flag.FlagSet
	includeMap := flags.Bool("include-map", false, "include map key/values in trace span")
	logLevel := flags.Int("loglevel", 0, "Set the log level. Higher numbers add more logging, Tops out at 3")
	opts := &protogen.Options{
		ParamFunc: flags.Set,
	}

	opts.Run(func(p *protogen.Plugin) error {
		for _, f := range p.Files {
			if !f.Generate {
				continue
			}
			cfg := config{
				includeMap: *includeMap,
				logLevel:   *logLevel,
			}

			generateFile(p, f, cfg)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, f *protogen.File, cfg config) {
	filename := f.GeneratedFilenamePrefix + "_otel.pb.go"

	g := gen.NewGeneratedFile(filename, f.GoImportPath)
	g.P("// Code generated by protoco-telemetry-go. DO NOT EDIT.")
	g.P()
	g.P("package ", f.GoPackageName)
	g.P()

	_ = g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "fmt"})

	setLogger(cfg.logLevel)
	fileGen := fields.NewFileGenerator(g)
	fileGen.Generate(g)

	msgs := collectMessages(f.Messages)

	for _, msg := range msgs {
		if msg.GoIdent.GoImportPath != f.GoImportPath {
			debug(msg.GoIdent.String(), "is unsupported. GoImportPath does not match")
			continue
		}
		if msg.Desc.IsMapEntry() {
			continue
		}
		debug("generating fields for messages", msg.GoIdent.GoName)
		g.P("func (x *", msg.GoIdent, ") TraceAttributes(ctx context.Context) {")
		g.P("span := trace.SpanFromContext(ctx)")
		g.P("span.SetAttributes(")
		for _, field := range msg.Fields {
			f := fields.NewFieldGenerator(field)
			f.Generate(g)
		}
		g.P(")")
		// map bits
		for _, field := range msg.Fields {
			if field.Desc.IsMap() {
				fields.NewMapGenerator(field).Generate(g)
			}
		}
		g.P("}")
		g.P()
	}
}

func collectMessages(msgs []*protogen.Message) MessageSet {
	set := make(MessageSet)
	for _, m := range msgs {
		debug("adding message", m.GoIdent.GoName, "to set")
		set.Add(m.GoIdent.String(), m)
		messageField := collectMessages(messagesFromFields(m.Fields))
		for _, localMsg := range messageField {
			debug("adding message", m.GoIdent.GoName, "to set")
			set.Add(localMsg.GoIdent.String(), localMsg)
		}
		for _, localMsg := range m.Messages {
			debug("adding message", m.GoIdent.GoName, "to set")
			set.Add(localMsg.GoIdent.String(), localMsg)
		}
	}
	return set
}

func messagesFromFields(f []*protogen.Field) []*protogen.Message {
	msgs := make([]*protogen.Message, 0)
	for _, field := range f {
		if field.Desc.Kind() != protoreflect.MessageKind {
			continue
		}
		if field.Desc.IsMap() {
			logger.Default().Debug(field.GoName, "is map")
			continue
		}
		msgs = append(msgs, field.Message)
	}
	return msgs
}

type MessageSet map[string]*protogen.Message

func (m MessageSet) Add(k string, v *protogen.Message) {
	if _, ok := m[k]; !ok {
		m[k] = v
	}
}

func (m MessageSet) Keys() []string {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}

func setLogger(i int) {
	var l logger.LogLevel
	if i < 0 {
		l = logger.Error
	} else if i > 3 {
		l = logger.Debug
	}
	switch i {
	case 0:
		l = logger.Error
	case 1:
		l = logger.Warn
	case 2:
		l = logger.Info
	case 3:
		l = logger.Debug
	default:
	}

	logger.SetLevel(l)
}

func debug(s ...string) {
	logger.Default().Debug(s...)
}
