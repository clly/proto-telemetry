package main

import (
	"flag"

	fields "github.com/clly/proto-telemetry/cmd/pkg/generators"
	"github.com/clly/proto-telemetry/cmd/pkg/logger"
	"google.golang.org/protobuf/compiler/protogen"
)

type config struct {
	includeMap bool
	logLevel   int
}

func main() {
	var flags flag.FlagSet
	includeMap := flags.Bool("include-map", false, "include map key/values in trace span")
	logLevel := flags.Int("loglevel", 0, "Set the log level. Higher numbers add more logging, Tops out at 3")
	opts := &protogen.Options{
		ParamFunc: flags.Set,
	}

	opts.Run(func(p *protogen.Plugin) error {
		for _, f := range p.Files {
			if !f.Generate {
				continue
			}
			cfg := config{
				includeMap: *includeMap,
				logLevel:   *logLevel,
			}

			generateFile(p, f, cfg)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, f *protogen.File, cfg config) {
	filename := f.GeneratedFilenamePrefix + "_otel.pb.go"

	g := gen.NewGeneratedFile(filename, f.GoImportPath)
	g.P("// Code generated by protoco-telemetry-go. DO NOT EDIT.")
	g.P()
	g.P("package ", f.GoPackageName)
	g.P()

	_ = g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "fmt"})

	setLogger(cfg.logLevel)
	fileGen := fields.NewFileGenerator(g)
	fileGen.Generate(g)

	msgs := collectMessages(f.Messages)

	for _, msgGenerator := range msgs {
		msg := msgGenerator.Proto()
		if msg.GoIdent.GoImportPath != f.GoImportPath {
			debug(msg.GoIdent.String(), "is unsupported. GoImportPath does not match")
			continue
		}
		if msg.Desc.IsMapEntry() {
			continue
		}
		debug("generating fields for messages", msg.GoIdent.GoName)
		msgGenerator.Generate(g)

		msgGenerator.Tail(g)
	}
}

func collectMessages(msgs []*protogen.Message) []fields.Message {
	messages := make([]fields.Message, 0, len(msgs))
	for _, m := range msgs {
		fieldMessage := fields.MessageGenerator(m)
		messages = append(messages, fieldMessage)
		debug("found message", m.GoIdent.GoName, "for generation")

		for _, child := range fieldMessage.Children() {
			messages = append(messages, child)
			debug("found child message", m.GoIdent.GoName, "for generation")
		}
	}
	return messages
}

func setLogger(i int) {
	var l logger.LogLevel
	if i < 0 {
		l = logger.Error
	} else if i > 3 {
		l = logger.Debug
	}
	switch i {
	case 0:
		l = logger.Error
	case 1:
		l = logger.Warn
	case 2:
		l = logger.Info
	case 3:
		l = logger.Debug
	default:
	}

	logger.SetLevel(l)
}

func debug(s ...string) {
	logger.Default().Debug(s...)
}
